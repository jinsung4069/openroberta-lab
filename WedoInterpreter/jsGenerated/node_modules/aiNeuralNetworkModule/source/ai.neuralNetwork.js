var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "svgdotjs", "jquery"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SVG = require("svgdotjs");
    var $ = require("jquery");
    var AiNeuralNetworkModule = /** @class */ (function () {
        function AiNeuralNetworkModule(selector, size) {
            var layers = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                layers[_i - 2] = arguments[_i];
            }
            this._aiNeuralNetwork = null;
            this._aiNeuralNetworkUI = null;
            $(selector).html('');
            this.svg = SVG.SVG().addTo(selector).size(size.width, size.height);
            this._aiNeuralNetwork = this.createNeuralNetwork.apply(this, layers);
            this._aiNeuralNetworkUI = new AiNeuralNetworkUI(this.aiNeuralNetwork, this.svg);
        }
        Object.defineProperty(AiNeuralNetworkModule.prototype, "aiNeuralNetwork", {
            get: function () {
                if (this._aiNeuralNetwork != null) {
                    return this._aiNeuralNetwork;
                }
                else {
                    return null;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AiNeuralNetworkModule.prototype, "aiNeuralNetworkUI", {
            get: function () {
                return this._aiNeuralNetworkUI;
            },
            enumerable: true,
            configurable: true
        });
        AiNeuralNetworkModule.prototype.createNeuralNetwork = function () {
            var layers = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                layers[_i] = arguments[_i];
            }
            if (this._aiNeuralNetwork != null) {
                return;
            }
            return AiNeuralNetwork.createNeuralNetwork(layers);
        };
        AiNeuralNetworkModule.prototype.calculateNeuralNetworkOutput = function () {
            this.aiNeuralNetwork.calculateNeuralNetworkOutput();
        };
        return AiNeuralNetworkModule;
    }());
    exports.AiNeuralNetworkModule = AiNeuralNetworkModule;
    var AiNeuralNetwork = /** @class */ (function () {
        function AiNeuralNetwork(layers, links) {
            this._layers = layers;
            this._links = links;
        }
        Object.defineProperty(AiNeuralNetwork.prototype, "layers", {
            get: function () {
                return this._layers;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AiNeuralNetwork.prototype, "links", {
            get: function () {
                return this._links;
            },
            enumerable: true,
            configurable: true
        });
        AiNeuralNetwork.createLinks = function (layers, weight) {
            if (weight === void 0) { weight = 0; }
            var links = [];
            for (var i = 0; i < layers.length - 1; i++) {
                var nodesFirstLayer = layers[i];
                var nodesSecondLayer = layers[i + 1];
                for (var node1Index in nodesFirstLayer) {
                    var node1 = nodesFirstLayer[node1Index];
                    for (var node2Index in nodesSecondLayer) {
                        var node2 = nodesSecondLayer[node2Index];
                        var link = new Link(node1, node2, weight);
                        links.push(link);
                    }
                }
            }
            return links;
        };
        AiNeuralNetwork.addNodesPositionXY = function (layerID, layer) {
            var i = 0;
            for (var _i = 0, layer_1 = layer; _i < layer_1.length; _i++) {
                var node = layer_1[_i];
                node.positionY = i;
                node.positionX = layerID;
                i++;
            }
        };
        AiNeuralNetwork.createNeuralNetwork = function (layers, initialWeight) {
            var links = AiNeuralNetwork.createLinks(layers, initialWeight);
            for (var layerID in layers) {
                var layer = layers[layerID];
                AiNeuralNetwork.addNodesPositionXY(parseInt(layerID), layer);
            }
            return new AiNeuralNetwork(layers, links);
        };
        AiNeuralNetwork.prototype.calculateNeuralNetworkOutput = function () {
            for (var i = 0; i < this._layers.length - 1; i++) {
                var nodesSecondLayer = this._layers[i + 1];
                for (var _i = 0, nodesSecondLayer_1 = nodesSecondLayer; _i < nodesSecondLayer_1.length; _i++) {
                    var node2 = nodesSecondLayer_1[_i];
                    node2.value = 0;
                    for (var _a = 0, _b = this._links; _a < _b.length; _a++) {
                        var link = _b[_a];
                        if (node2 == link.node2) {
                            node2.value = node2.value + (link.node1.value * link.weight);
                        }
                    }
                }
            }
        };
        AiNeuralNetwork.prototype.getInputLayer = function () {
            return this._layers[0];
        };
        AiNeuralNetwork.prototype.getOutputLayer = function () {
            return this._layers[this._layers.length - 1];
        };
        return AiNeuralNetwork;
    }());
    exports.AiNeuralNetwork = AiNeuralNetwork;
    var Node = /** @class */ (function () {
        function Node(value, threshold) {
            this.value = value;
            this.threshold = threshold;
        }
        Object.defineProperty(Node.prototype, "positionX", {
            get: function () {
                return this._positionX;
            },
            set: function (value) {
                this._positionX = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Node.prototype, "positionY", {
            get: function () {
                return this._positionY;
            },
            set: function (value) {
                this._positionY = value;
            },
            enumerable: true,
            configurable: true
        });
        return Node;
    }());
    exports.Node = Node;
    var Ev3MotorOutputNode = /** @class */ (function (_super) {
        __extends(Ev3MotorOutputNode, _super);
        function Ev3MotorOutputNode(value, threshold, port, type) {
            var _this = _super.call(this, value, threshold) || this;
            _this._port = port;
            _this._type = type;
            return _this;
        }
        Object.defineProperty(Ev3MotorOutputNode.prototype, "port", {
            get: function () {
                return this._port;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Ev3MotorOutputNode.prototype, "type", {
            get: function () {
                return this._type;
            },
            enumerable: true,
            configurable: true
        });
        return Ev3MotorOutputNode;
    }(Node));
    exports.Ev3MotorOutputNode = Ev3MotorOutputNode;
    var Link = /** @class */ (function (_super) {
        __extends(Link, _super);
        function Link(node1, node2, _weight) {
            var _this = _super.call(this) || this;
            _this.node1 = node1;
            _this.node2 = node2;
            _this._weight = _weight;
            return _this;
        }
        Object.defineProperty(Link.prototype, "weight", {
            get: function () {
                return this._weight;
            },
            set: function (value) {
                this._weight = value;
                var event = new CustomEvent('weightChanged', { detail: value });
                this.dispatchEvent(event);
            },
            enumerable: true,
            configurable: true
        });
        return Link;
    }(EventTarget));
    exports.Link = Link;
    var LinkUI = /** @class */ (function (_super) {
        __extends(LinkUI, _super);
        function LinkUI(link, svg, draggable) {
            var _this = _super.call(this) || this;
            _this.link = link;
            _this.svg = svg;
            _this.draggable = draggable;
            _this.isActivated = false;
            _this.drawSlider();
            _this.addLinkListener();
            return _this;
        }
        ;
        LinkUI.prototype.drawSlider = function () {
            var that = this;
            var path = LinkUI.createPathForLink(this.link, this.svg)
                .stroke(LinkUI.COLOR_DEFAULT);
            var circle = this.svg.circle()
                .radius(8)
                .fill('red')
                .click(function () {
                that.activateLink();
            });
            this.slider = SVGSlider.createSlider(path, LinkUI.RANGE_MIN, LinkUI.RANGE_MAX, circle, LinkUI.STARTPOINT, path.length(), this.link.weight);
            this.slider.addEventListener('sliderValueChanged', function (sliderValueData) {
                that.link.weight = sliderValueData.detail;
            });
            this.updateSliderPathOnWeightChange(this.link.weight);
            this.draggable.registerDraggableElement(circle);
        };
        LinkUI.createPathForLink = function (link, svg) {
            var node1PositionXY = AiNeuralNetworkUI.getNodeXY(link.node1.positionX, link.node1.positionY);
            var node2PositionXY = AiNeuralNetworkUI.getNodeXY(link.node2.positionX, link.node2.positionY);
            return SVGUtils.createPath(svg, node1PositionXY.x, node1PositionXY.y, node2PositionXY.x, node2PositionXY.y);
        };
        LinkUI.prototype.addLinkListener = function () {
            var that = this;
            this.link.addEventListener('weightChanged', function (event) {
                that.updateSliderPathOnWeightChange(event.detail);
            });
            this.slider.path
                .mouseover(function () {
                this.stroke(LinkUI.COLOR_ACTIVE);
                console.log("Link mouseover");
            })
                .mouseout(function () {
                if (!that.isActivated) {
                    this.stroke(LinkUI.COLOR_INACTIVE);
                    console.log("Link mouseout");
                }
            })
                .click(function () {
                console.log(that.link);
                that.activateLink();
            });
        };
        LinkUI.prototype.updateSliderPathOnWeightChange = function (weight) {
            var width = weight * 4 + 2;
            this.slider.path.stroke({ width: width });
        };
        LinkUI.prototype.activateLink = function () {
            this.isActivated = true;
            this.slider.path.stroke(LinkUI.COLOR_ACTIVE).front();
            this.slider.sliderShape.front();
            var event = new CustomEvent('linkActivated');
            console.log("Link aktiviert");
            this.dispatchEvent(event);
        };
        LinkUI.prototype.deactivateLink = function () {
            this.isActivated = false;
            this.slider.path.stroke(LinkUI.COLOR_INACTIVE);
            console.log("Link deaktiviert");
        };
        LinkUI.COLOR_ACTIVE = 'black';
        LinkUI.COLOR_INACTIVE = '#b5cb5f';
        LinkUI.COLOR_DEFAULT = '#b5cb5f';
        LinkUI.RANGE_MIN = 0;
        LinkUI.RANGE_MAX = 1;
        LinkUI.STARTPOINT = 0;
        return LinkUI;
    }(EventTarget));
    exports.LinkUI = LinkUI;
    var Draggable = /** @class */ (function () {
        function Draggable(area) {
            this.area = area;
            this.draggingElement = null;
        }
        Draggable.create = function (area) {
            var draggable = new Draggable(area);
            draggable.draggableEventHandling();
            return draggable;
        };
        Draggable.prototype.draggableEventHandling = function () {
            var that = this;
            this.area.mousemove(function (e) {
                e.stopPropagation();
                if (that.draggingElement != null) {
                    that.draggingElement.dispatch('dragmove', e);
                    console.log("dragmove");
                }
            });
            $(document).mouseup(function (e) {
                if (that.draggingElement != null) {
                    that.draggingElement.fire('dragend');
                    console.log("dragend");
                    that.draggingElement = null;
                }
            });
        };
        Draggable.prototype.registerDraggableElement = function (element) {
            var that = this;
            element.mousedown(function () {
                that.draggingElement = this;
                that.draggingElement.fire('dragstart');
                console.log("dragstart");
            });
        };
        return Draggable;
    }());
    exports.Draggable = Draggable;
    var AiNeuralNetworkUI = /** @class */ (function () {
        function AiNeuralNetworkUI(neuralNetwork, svg) {
            this.neuralNetwork = neuralNetwork;
            this.svg = svg;
            this.draggable = Draggable.create(svg);
            this.drawNeuralNetwork();
        }
        AiNeuralNetworkUI.prototype.drawNeuralNetwork = function () {
            this.drawLinks(this.neuralNetwork.links);
            this.drawLayer(this.neuralNetwork.layers[0]);
            this.drawLayer(this.neuralNetwork.layers[1]);
        };
        AiNeuralNetworkUI.prototype.drawLayer = function (layer) {
            for (var _i = 0, layer_2 = layer; _i < layer_2.length; _i++) {
                var node = layer_2[_i];
                var nodePositionXY = AiNeuralNetworkUI.getNodeXY(node.positionX, node.positionY);
                var circle = this.svg.circle()
                    .radius(20)
                    .cx(nodePositionXY.x)
                    .cy(nodePositionXY.y)
                    .fill('black');
            }
        };
        AiNeuralNetworkUI.prototype.drawLinks = function (links) {
            var that = this;
            for (var _i = 0, links_1 = links; _i < links_1.length; _i++) {
                var link = links_1[_i];
                var linkUI = new LinkUI(link, this.svg, this.draggable);
                linkUI.addEventListener('linkActivated', function (event) {
                    if (that.activeLinkUI != undefined) {
                        that.activeLinkUI.deactivateLink();
                    }
                    that.activeLinkUI = this;
                });
            }
        };
        AiNeuralNetworkUI.getNodeXY = function (nodePositionX, nodePositionY) {
            var x = AiNeuralNetworkUI.LAYER_OFFSET_LEFT + AiNeuralNetworkUI.HORIZONTAL_DISTANCE_BETWEEN_TWO_NODES * nodePositionX;
            var y = AiNeuralNetworkUI.LAYER_OFFSET_TOP + AiNeuralNetworkUI.VERTICAL_DISTANCE_BETWEEN_TWO_NODES * nodePositionY;
            return { x: x, y: y };
        };
        AiNeuralNetworkUI.LAYER_OFFSET_TOP = 20;
        AiNeuralNetworkUI.LAYER_OFFSET_LEFT = 50;
        AiNeuralNetworkUI.HORIZONTAL_DISTANCE_BETWEEN_TWO_NODES = 170;
        AiNeuralNetworkUI.VERTICAL_DISTANCE_BETWEEN_TWO_NODES = 70;
        return AiNeuralNetworkUI;
    }());
    exports.AiNeuralNetworkUI = AiNeuralNetworkUI;
    var SVGSlider = /** @class */ (function (_super) {
        __extends(SVGSlider, _super);
        function SVGSlider(_path, rangeMin, rangeMax, _sliderShape, startPoint, endPoint, _sliderValue) {
            if (startPoint === void 0) { startPoint = 0; }
            if (endPoint === void 0) { endPoint = _path.length(); }
            var _this = _super.call(this) || this;
            _this._path = _path;
            _this.rangeMin = rangeMin;
            _this.rangeMax = rangeMax;
            _this._sliderShape = _sliderShape;
            _this.startPoint = startPoint;
            _this.endPoint = endPoint;
            _this._sliderValue = _sliderValue;
            _this.sliderValue = _sliderValue;
            return _this;
        }
        Object.defineProperty(SVGSlider.prototype, "path", {
            get: function () {
                return this._path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SVGSlider.prototype, "sliderShape", {
            get: function () {
                return this._sliderShape;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SVGSlider.prototype, "sliderValue", {
            get: function () {
                return this._sliderValue;
            },
            set: function (value) {
                this._sliderValue = value;
                var pointOnPath = this.path.node.getPointAtLength(this.path.node.getTotalLength() * value);
                this.sliderShape.cx(pointOnPath.x + 20).cy(pointOnPath.y);
                var event = new CustomEvent('sliderValueChanged', { detail: value });
                console.log("slidervalue changed: " + value);
                this.dispatchEvent(event);
            },
            enumerable: true,
            configurable: true
        });
        SVGSlider.createSlider = function (path, rangeMin, rangeMax, sliderShape, startPoint, endPoint, sliderValue) {
            if (endPoint === void 0) { endPoint = path.length(); }
            if (sliderValue === void 0) { sliderValue = 0; }
            var slider = new SVGSlider(path, rangeMin, rangeMax, sliderShape, startPoint, endPoint, sliderValue);
            slider.sliderShape.on('dragmove', function (e) {
                var mouseEvent = e.detail;
                var m = path.root().point(mouseEvent.pageX, mouseEvent.pageY), p = SVGUtils.closestPoint(path.node, m);
                sliderShape.cx(p.x).cy(p.y);
                var sliderShapeCenter = { x: sliderShape.cx(), y: sliderShape.cy() };
                slider.sliderValue = SVGUtils.getPositionOnPath(path, sliderShapeCenter, SVGSlider.ACCURACY, rangeMax);
            });
            return slider;
        };
        SVGSlider.ACCURACY = 100;
        return SVGSlider;
    }(EventTarget));
    exports.SVGSlider = SVGSlider;
    var SVGUtils = /** @class */ (function () {
        function SVGUtils() {
        }
        SVGUtils.createPath = function (svg, node1PositionX, node1PositionY, node2PositionX, node2PositionY) {
            return svg.path([
                ['M', node1PositionX, node1PositionY],
                ['L', node2PositionX, node2PositionY]
            ]);
        };
        SVGUtils.closestPoint = function (pathNode, point) {
            var pathLength = pathNode.getTotalLength(), precision = 8, best, bestLength, bestDistance = Infinity;
            // linear scan for coarse approximation
            for (var scan, scanLength = 0, scanDistance; scanLength <= pathLength; scanLength += precision) {
                if ((scanDistance = SVGUtils.distance2(point, scan = pathNode.getPointAtLength(scanLength))) < bestDistance) {
                    best = scan, bestLength = scanLength, bestDistance = scanDistance;
                }
            }
            // binary search for precise estimate
            precision /= 2;
            while (precision > 0.5) {
                var before, after, beforeLength, afterLength, beforeDistance, afterDistance;
                if ((beforeLength = bestLength - precision) >= 0 && (beforeDistance = SVGUtils.distance2(point, before = pathNode.getPointAtLength(beforeLength))) < bestDistance) {
                    best = before, bestLength = beforeLength, bestDistance = beforeDistance;
                }
                else if ((afterLength = bestLength + precision) <= pathLength && (afterDistance = SVGUtils.distance2(point, after = pathNode.getPointAtLength(afterLength))) < bestDistance) {
                    best = after, bestLength = afterLength, bestDistance = afterDistance;
                }
                else {
                    precision /= 2;
                }
            }
            return { x: best.x, y: best.y, distance: Math.sqrt(bestDistance) };
        };
        SVGUtils.distance2 = function (point, p) {
            var dx = p.x - point.x, dy = p.y - point.y;
            return dx * dx + dy * dy;
        };
        SVGUtils.getPositionOnPath = function (path, point, accuracy, fullWeight) {
            var totalLength = path.node.getTotalLength();
            var step = totalLength / accuracy;
            var t = 0;
            var currentDistance;
            var minDistanceData = { "t": t, "distance": Number.MAX_VALUE };
            /**
             * <--        totalLength         -->
             * <step> <step> <step> <step> <step>
             * ------|------|------|---*--|------
             *       t-->         cirlceCenter
             *       <--  distance  -->
             *
             */
            for (t = 0; t <= totalLength; t += step) {
                t = SVGUtils.round(t, 4);
                currentDistance = SVGUtils.calcDistance(path.node.getPointAtLength(t), point);
                if (currentDistance < minDistanceData.distance) {
                    minDistanceData = { "t": t, "distance": currentDistance }; //p2 - distance from point at length to circle center
                }
            }
            var sliderValue = minDistanceData.t / step * fullWeight / accuracy;
            return sliderValue;
        };
        SVGUtils.round = function (num, places) {
            var multiplier = Math.pow(10, places);
            return (Math.round(num * multiplier) / multiplier);
        };
        SVGUtils.calcDistance = function (p1, p2) {
            return Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2);
        };
        return SVGUtils;
    }());
    exports.SVGUtils = SVGUtils;
});
