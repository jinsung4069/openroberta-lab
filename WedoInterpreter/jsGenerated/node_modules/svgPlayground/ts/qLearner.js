var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./models", "./aiReinforcementLearningModule"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var models_1 = require("./models");
    var aiReinforcementLearningModule_1 = require("./aiReinforcementLearningModule");
    var QLearningAlgorithm = /** @class */ (function (_super) {
        __extends(QLearningAlgorithm, _super);
        function QLearningAlgorithm(problem, alpha, gamma, rho, nu) {
            var _this = _super.call(this) || this;
            _this.problem = problem;
            _this.qValueStore = new QValueStore(problem.statesAndActions);
            _this.state = _this.problem.getRandomState();
            _this.stepNumber = 0;
            _this.alpha = alpha;
            _this.gamma = gamma;
            _this.rho = rho;
            _this.nu = nu;
            return _this;
        }
        QLearningAlgorithm.prototype.qLearnerStep = function () {
            var action;
            var nu = Math.random() < this.nu ? models_1.Nu.RANDOM_STATE : models_1.Nu.STAY_ON_PATH;
            var rho = Math.random() < this.rho ? models_1.Rho.EXPLORE : models_1.Rho.EXPLOIT;
            var startTime = Date.now();
            var qValueOld;
            var qValueNew;
            var newState;
            var duration;
            if (nu == models_1.Nu.RANDOM_STATE) {
                this.state = this.problem.getRandomState();
            }
            var state = this.state;
            var actions = this.problem.getAvailableActions(this.state);
            switch (rho) {
                case models_1.Rho.EXPLORE:
                    action = this.problem.takeOneOfActions(actions);
                    break;
                case models_1.Rho.EXPLOIT:
                    action = this.qValueStore.getBestAction(this.state, actions);
                    break;
            }
            var rewardAndNewState = this.problem.takeAction(this.state, action);
            var reward = rewardAndNewState.reward;
            newState = rewardAndNewState.newState;
            qValueOld = this.qValueStore.getQValue(this.state, action);
            var newStateActions = this.problem.getAvailableActions(newState);
            var maxQ = this.qValueStore.getQValue(newState, this.qValueStore.getBestAction(newState, newStateActions));
            qValueNew = (1 - this.alpha) * qValueOld + this.alpha * (reward + this.gamma * maxQ);
            this.qValueStore.storeQValue(this.state, action, qValueNew);
            console.log(this.qValueStore);
            console.log("state " + this.state + " > " + newState + "; reward " + reward + "; q " + qValueNew + "; maxQ " + maxQ);
            this.state = newState;
            duration = Date.now() - startTime;
            var qLearningStep = {
                newState: newState,
                nu: nu,
                qValueNew: qValueNew,
                qValueOld: qValueOld,
                rho: rho,
                state: state,
                duration: duration,
                stepNumber: this.stepNumber
            };
            this.dispatchEvent(new CustomEvent("stepCompleted", {
                detail: qLearningStep
            }));
            this.stepNumber++;
            return qLearningStep;
        };
        QLearningAlgorithm.prototype.findOptimalPath = function (startState, finishState) {
            return this.qValueStore.createOptimalPath(startState, finishState, this.problem);
        };
        return QLearningAlgorithm;
    }(EventTarget));
    exports.QLearningAlgorithm = QLearningAlgorithm;
    var QValueStore = /** @class */ (function () {
        function QValueStore(statesAndActions) {
            this.qMatrix = [];
            for (var statesIndex in statesAndActions) {
                var actions = statesAndActions[statesIndex].slice().fill(0);
                this.qMatrix.push(actions);
            }
        }
        QValueStore.prototype.getQValue = function (state, action) {
            var actions = this.qMatrix[state];
            return actions[action]; //associatedQValue
        };
        QValueStore.prototype.getBestAction = function (state, availableActions) {
            var actionsQMatrix = this.qMatrix[state];
            var bestActionValue = -1;
            var bestAction;
            for (var actionIndex in actionsQMatrix) {
                var action = actionsQMatrix[actionIndex];
                if (action != undefined && availableActions.includes(parseInt(actionIndex)) && action > bestActionValue) {
                    bestActionValue = actionsQMatrix[actionIndex];
                    bestAction = parseInt(actionIndex);
                }
            }
            return bestAction;
        };
        QValueStore.prototype.storeQValue = function (state, action, value) {
            var actions = this.qMatrix[state];
            actions[action] = value; // === this.qMatrix[state][action] = value;
        };
        //TODO Optimize calculating of the best path
        QValueStore.prototype.createOptimalPath = function (startState, endState, problem) {
            var optimalPath = [startState];
            var currentState = startState;
            var resultState = aiReinforcementLearningModule_1.ResultState.SUCCESS;
            while (currentState !== endState) {
                var nextState = this.getBestAction(currentState, problem.getAvailableActions(currentState));
                currentState = nextState;
                if (optimalPath.includes(currentState)) {
                    console.log("Keinen optimalen Pfad von " + startState + " nach " + endState + " gefunden. Zyklus geschlossen bei: " + currentState);
                    resultState = aiReinforcementLearningModule_1.ResultState.ERROR;
                    break;
                }
                optimalPath.push(nextState);
            }
            return { optimalPath: optimalPath, resultState: resultState };
        };
        return QValueStore;
    }());
    var ReinforcementProblem = /** @class */ (function () {
        function ReinforcementProblem(statesAndActions) {
            this.statesAndActions = statesAndActions;
            this.states = [];
            for (var i = 0; i < statesAndActions.length; i++) {
                this.states.push(i);
            }
        }
        ReinforcementProblem.prototype.getRandomState = function () {
            var indexOfState = Math.floor(Math.random() * this.states.length);
            return this.states[indexOfState];
        };
        ReinforcementProblem.prototype.getAvailableActions = function (state) {
            var availableActions = [];
            var actions = this.statesAndActions[state];
            for (var _i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
                var action = actions_1[_i];
                if (action !== undefined) {
                    availableActions.push(action);
                }
            }
            return availableActions;
        };
        ReinforcementProblem.prototype.takeAction = function (state, action) {
            var actions = this.statesAndActions[state];
            return {
                "reward": actions[action],
                "newState": action
            };
        };
        ReinforcementProblem.prototype.takeOneOfActions = function (actions) {
            var action = Math.floor(Math.random() * actions.length);
            return actions[action];
        };
        return ReinforcementProblem;
    }());
});
