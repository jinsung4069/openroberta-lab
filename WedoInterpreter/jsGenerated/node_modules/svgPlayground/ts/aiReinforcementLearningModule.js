var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./visualizer", "./utils", "./playerImpl", "./qLearner"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var visualizer_1 = require("./visualizer");
    var utils_1 = require("./utils");
    var playerImpl_1 = require("./playerImpl");
    var qLearner_1 = require("./qLearner");
    var QLearningAlgorithmModule = /** @class */ (function () {
        function QLearningAlgorithmModule(updateBackground, htmlSelector, size, pathToSvg) {
            this.htmlSelector = htmlSelector;
            this.size = size;
            this.pathToSvg = pathToSvg;
            this.problem = undefined;
            this.qValueStore = undefined;
            this.episodes = 500;
            this.totalTime = 300;
            this.startFinishStates = undefined;
            this.player = undefined;
            this.qLearner = undefined;
            this._drawOptimalPathResult = undefined;
        }
        QLearningAlgorithmModule.prototype.createQLearningEnvironment = function (obstaclesList, startNode, finishNode) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, notAllowedActions, allActions, statesAndActions;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _a = this;
                            return [4 /*yield*/, visualizer_1.Visualizer.createVisualizer(this.pathToSvg, this.htmlSelector, this.size)];
                        case 1:
                            _a.visualizer = _b.sent();
                            notAllowedActions = utils_1.Utils.convertObstacleListToActionList(obstaclesList);
                            this.startFinishStates = utils_1.Utils.convertStartFinishNodeToAction(startNode, finishNode);
                            allActions = this.visualizer.getActions();
                            //visualiser gets obstacle list and draws rocks on the way
                            this.visualizer.processNotAllowedActions(notAllowedActions);
                            //filter out all actions from obstacle lists -> work with the same list
                            allActions = utils_1.Utils.filterOutNotAllowedActions(allActions, notAllowedActions);
                            statesAndActions = RlUtils.generateRewardsAndProblem(allActions, this.startFinishStates);
                            this.problem = new ReinforcementProblem(statesAndActions);
                            return [2 /*return*/];
                    }
                });
            });
        };
        QLearningAlgorithmModule.prototype.setUpQLearningBehaviour = function (alpha, gamma, nu, rho) {
            this.alpha = alpha;
            this.gamma = gamma;
            this.nu = nu;
            this.rho = rho;
        };
        QLearningAlgorithmModule.prototype.runQLearner = function () {
            this.qLearner = new qLearner_1.QLearningAlgorithm(this.problem, this.alpha, this.gamma, this.rho, this.nu);
            var qLearningSteps = new Array();
            for (var i = 0; i < this.episodes; i++) {
                qLearningSteps.push({
                    qLearnerStepData: this.qLearner.qLearnerStep(),
                    optimalPath: this.qLearner.findOptimalPath(this.startFinishStates.startState.id, this.startFinishStates.finishState.id).optimalPath
                });
            }
            this.player = new playerImpl_1.PlayerImpl(qLearningSteps, this.totalTime, this.episodes, this.startFinishStates);
            this.player.initialize(this.visualizer);
        };
        QLearningAlgorithmModule.prototype.drawOptimalPath = function () {
            var that = this;
            this.player.timer.addEventListener("stop", function () {
                var optimalPathResult = that.qLearner.findOptimalPath(that.startFinishStates.startState.id, that.startFinishStates.finishState.id);
                if (optimalPathResult.resultState == ResultState.ERROR) {
                    console.log(optimalPathResult.optimalPath + "ist not an optimal Path.");
                }
                that.visualizer.drawPath(optimalPathResult.optimalPath);
            });
            // var copyOfSVG: SVG.Svg = this.svg.clone();
            // RlUtils.hideAllPathsExeptTheOptimal(copyOfSVG);
            // var learnedImageHTML = copyOfSVG.svg();
            // var learnedImage = window.btoa(learnedImageHTML);
            // var temp: string = 'data:image/svg+xml;base64,' + learnedImage;
            // this.updateBackground(9, temp);
        };
        Object.defineProperty(QLearningAlgorithmModule.prototype, "drawOptimalPathResult", {
            get: function () {
                return this._drawOptimalPathResult;
            },
            set: function (value) {
                this._drawOptimalPathResult = value;
            },
            enumerable: true,
            configurable: true
        });
        return QLearningAlgorithmModule;
    }());
    exports.QLearningAlgorithmModule = QLearningAlgorithmModule;
    var RlUtils = /** @class */ (function () {
        function RlUtils() {
        }
        RlUtils.generateRewardsAndProblem = function (allActions, startFinishState) {
            var statesAndActions = new Array();
            for (var _i = 0, allActions_1 = allActions; _i < allActions_1.length; _i++) {
                var action = allActions_1[_i];
                if (statesAndActions[action.startState.id] == undefined) {
                    statesAndActions[action.startState.id] = new Array();
                }
                var rewardValue = RlUtils.DEFAULT_REWARD_VALUE;
                if (action.finishState.id == startFinishState.finishState.id) {
                    rewardValue = this.REWARD_VALUE;
                }
                statesAndActions[action.startState.id][action.finishState.id] = rewardValue;
            }
            return statesAndActions;
        };
        RlUtils.hideAllPathsExeptTheOptimal = function (svg) {
            svg.find('.cls-customPathColor').hide();
        };
        RlUtils.REWARD_VALUE = 50;
        RlUtils.DEFAULT_REWARD_VALUE = 0;
        return RlUtils;
    }());
    // exports.QLearningAlgorithmModule = QLearningAlgorithmModule;
    //Utils
    var ResultState;
    (function (ResultState) {
        ResultState[ResultState["SUCCESS"] = 1] = "SUCCESS";
        ResultState[ResultState["ERROR"] = 2] = "ERROR";
    })(ResultState = exports.ResultState || (exports.ResultState = {}));
    var ReinforcementProblem = /** @class */ (function () {
        function ReinforcementProblem(statesAndActions) {
            this.statesAndActions = statesAndActions;
            this.states = [];
            for (var i = 0; i < statesAndActions.length; i++) {
                this.states.push(i);
            }
        }
        ReinforcementProblem.prototype.getRandomState = function () {
            var indexOfState = Math.floor(Math.random() * this.states.length);
            return this.states[indexOfState];
        };
        ReinforcementProblem.prototype.getAvailableActions = function (state) {
            var availableActions = [];
            var actions = this.statesAndActions[state];
            var actionIndex;
            for (actionIndex in actions) {
                if (actions[actionIndex] !== undefined) {
                    availableActions.push(parseInt(actionIndex));
                }
            }
            return availableActions;
        };
        ReinforcementProblem.prototype.takeAction = function (state, action) {
            var actions = this.statesAndActions[state];
            return {
                "reward": actions[action],
                "newState": action
            };
        };
        ReinforcementProblem.prototype.takeOneOfActions = function (actions) {
            var action = Math.floor(Math.random() * actions.length);
            return actions[action];
        };
        return ReinforcementProblem;
    }());
    var QValueStore = /** @class */ (function () {
        function QValueStore(statesAndActions) {
            this.qMatrix = [];
            for (var statesIndex in statesAndActions) {
                var actions = statesAndActions[statesIndex].slice().fill(0);
                this.qMatrix.push(actions);
            }
        }
        QValueStore.prototype.getQValue = function (state, action) {
            var actions = this.qMatrix[state];
            return actions[action]; //associatedQValue
        };
        QValueStore.prototype.getBestAction = function (state, availableActions) {
            var actionsQMatrix = this.qMatrix[state];
            var bestActionValue = -1;
            var bestAction;
            for (var actionIndex in actionsQMatrix) {
                var action = actionsQMatrix[actionIndex];
                if (action != undefined && availableActions.includes(parseInt(actionIndex)) && action > bestActionValue) {
                    bestActionValue = actionsQMatrix[actionIndex];
                    bestAction = parseInt(actionIndex);
                }
            }
            return bestAction;
        };
        QValueStore.prototype.storeQValue = function (state, action, value) {
            var actions = this.qMatrix[state];
            actions[action] = value; // === this.qMatrix[state][action] = value;
        };
        QValueStore.prototype.createOptimalPath = function (startState, endState, problem) {
            var optimalPath = [startState];
            var currentState = startState;
            var resultState = ResultState.SUCCESS;
            while (currentState !== endState) {
                var nextState = this.getBestAction(currentState, problem.getAvailableActions(currentState));
                currentState = nextState;
                if (optimalPath.includes(currentState)) {
                    console.log("Keinen optimalen Pfad von " + startState + " nach " + endState + " gefunden. Zyklus geschlossen bei: " + currentState);
                    resultState = ResultState.ERROR;
                    break;
                }
                optimalPath.push(nextState);
            }
            return { optimalPath: optimalPath, resultState: resultState };
        };
        return QValueStore;
    }());
});
